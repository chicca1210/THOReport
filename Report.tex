% !TeX spellcheck = it_IT
\documentclass[12pt, italian]{article}
\usepackage[utf8]{inputenc}
\usepackage {graphicx}
\usepackage{hyperref} 
\usepackage{float}
\usepackage{enumitem}

\title{\textbf{THO\\Treasure Hunt Organizer}}
\author{
	Caselli, Ashley\\
	\texttt{ashley.caselli@studio.unibo.it}
	\and
	Mambelli, Giacomo\\
	\texttt{giacomo.mambelli@studio.unibo.it}
	\and
	Tassinari, Francesca\\
	\texttt{francesc.tassinari10@studio.unibo.it}
	\and
	Vattimo, Carmine\\
	\texttt{carmine.vattimo@studio.unibo.it}
}
\date{\today}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage

\section{Introduzione}
% descrizione anche sommaria di cosa il sistema implementato realizza
% This document contains the final work of PPS course. The goal has been
% Il focus di tale progetto è, oltre all'effettivo sviluppo del sistema, il processo adottato per lo sviluppo in team, mettendo in pratica al meglio possibile ciò che è stato ampiamente studiato nel corso.
Questo documento contiene il frutto del lavoro svoltosi durante il corso di Sviluppo dei Sistemi Software. L'obbiettivo di questo progetto, oltre allo sviluppo del sistema, è concentrarsi sul lavoro in team e di suddivisione dei compiti in un gruppo.
Lo scopo del progetto è la creazione di un sistema software utilizzando buone tecniche di progettazione, implementazione, organizzazione del team e flusso di lavoro. Ultimo, ma non meno importante, è l'applicazione nel migliore modo possibile degli insegnamenti appresi durante il corso.\\

THO (Treasure Hunt Organizer) è un sistema software che funge da supporto all'organizzazione e alla fase di gioco di una caccia al tesoro. Il sistema fornisce un'applicazione desktop all'organizzatore della caccia al tesoro, ed una web app progettata per i giocatori.\\
Il modulo desktop è un applicazione pensata per rendere il più semplice possibile l'organizzazione di una caccia al tesoro. Questo scopo viene raggiunto mediate una GUI minimale che permette di gestire le cacce al tesoro con i loro punti di interesse (tappe).\\

I giocatori, tramite la loro applicazione per smartphone, saranno in grado di partecipare alla caccia al tesoro attraverso una mappa che segue la posizione GPS del telefono, e un sistema di quiz e indizi per aiutarli a raggiungere il prossimo punto di interesse.\\
Tutti i dati di tutte le cacce al tesoro, sono immagazzinati in un database, alla quale si accede attraverso un server, a cui è delegata anche la gestione della comunicazione.

\newpage
\section{Processo di sviluppo adottato}
%Processo di sviluppo adottato (modalità di divisione in itinere dei task, meeting/interazioni pianificate, modalità di revisione in itinere dei task, scelta degli strumenti di test/build/continuous integration)
In accordo con i temi proposti nel corso si è deciso di abbracciare il manifesto Agile, in particolare il framework Scrum per la gestione del ciclo di sviluppo del software.\\
In breve l'utilizzo di tale framework prevede la divisione del team in ruoli specifici come Product Owner (PO), Sviluppatori che compongono il Team di Sviluppo e Scrum Master. In questo caso, pur adottando Scrum, non sono state seguite le linee guida alla perfezione poiché non è stato possibile per ovvie ragioni avere la presenza dello Scrum Master. Inoltre, sempre seguendo le linee guida, il Product Owner non dovrebbe far parte del Team di Sviluppo; regola che è stata violata in questo progetto per semplificare la gestione.

\subsection{Metodologia di sviluppo}
Come primo passo è stato identificato il Product Owner (PO) nella persona di Carmine Vattimo poiché autore della proposta di progetto. Come descritto in precedenza il PO è stato incluso nel Team di Sviluppo che è composto da tutti i componenti del gruppo.\\
Completata la suddivisione dei ruoli siamo passati alla gestione del flusso di lavoro ed alla suddivisione dei task per ogni componente del gruppo. Sono state identificate le modalità di sviluppo programmando sprint fissi ogni 1/2 settimane a seconda del carico di lavoro presente all'interno di ognuno di essi.\\
Dopo una accurata valutazione è stato deciso di suddividere il lavoro in 5 sprint, come è evidenziato dal product backlog (\ref{product_backlog}).
Al termine di ogni sprint si è tenuta una sprint review per analizzare il lavoro svolto, discutere delle difficoltà riscontrate e programmare il nuovo sprint. Inoltre, durante il corso di ogni sprint c'è stata una comunicazione costante per favorire la collaborazione tra i vari membri del team.
\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/backlog01.png}
    \caption{Product Backlog}
    \label{product_backlog}
\end{figure}
\subsection{Strumenti di sviluppo}
Di seguito vengono elencati gli strumenti che sono stati scelti per la gestione e realizzazione del progetto:
\begin{itemize}
	\item \textbf{Trello} utilizzato come strumento per l'organizzazione del team e per la gestione del progetto in accordo con le modalità di Scrum (Backlog virtuale, \ref{trello_board}). Diversi plugin sono stati utilizzati in modo da semplificare la gestione del conto ore
	\item \textbf{Gradle} utilizzato come supporto alla gestione delle dipendenze ed al ciclo di vita del progetto
	\item \textbf{IntelliJ IDEA} utilizzato come ambiente di sviluppo principale
	\item \textbf{Git} utilizzato per il controllo delle versioni, in particolare usando il Git Flow descritto a lezione
	\item \textbf{GitHub} utilizzato come servizio di repository remoto
	\item \textbf{Travis CI} integrato con il repo GitHub, è stato utilizzato per le funzionalità di Continuous Integration (build and test) e Continuous Deployment
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=1\textwidth]{img/trello01.png}
    \caption{Bacheca Trello}
    \label{trello_board}
\end{figure}

\newpage
\section{Requisiti}
THO è un sistema software utilizzato per supportare l'organizzazione e la fase di gioco di cacce al tesoro. Tale software è composto da due sotto-componenti principali: l'organizzatore ed i giocatori partecipanti alla caccia al tesoro.\\
Il sotto-sistema organizzatore consiste in un'applicazione desktop che permette di scegliere una città/location per il gioco tramite una mappa interattiva. Successivamente è possibile delinearne il percorso che sarà composto dai punti di interesse (tappe). Viene resa inoltre possibile la creazione di mini giochi/indovinelli che corrisponderanno alle prove da superare nel momento in cui i partecipanti raggiungeranno le varie tappe.\\
Lato giocatori è presente un applicativo mobile che permette di visualizzare le cacce al tesoro disponibili ed iscriversi attraverso l'utilizzo di un codice univoco fornitogli precedentemente (lettura di un QR code o inserimento manuale del codice). Entrati nella modalità di gioco l'applicativo, tramite il GPS, li colloca sulla mappa di gioco e consente di avvisarli nel momento in cui viene raggiunto un determinato punto di interesse. Nel momento in cui viene raggiunto il punto di interesse gli viene sottoposto un mini gioco da superare sotto forma di quiz o indovinello da risolvere ed, una volta risolto correttamente, gli verrà fornito un indizio per permettergli di raggiungere il successivo punto di interesse.
Durante la fase di gioco è inoltre possibile controllarne l'andamento, visualizzando le posizioni dei giocatori su una mappa ed eventualmente dare indicazioni live ai giocatori riguardanti il punto di interesse a cui sono diretti.\\
% ci si può iscrivere finchè la caccia al tesoro è aperta ed iniziata
\subsection{Requisiti funzionali}
\begin{itemize}
	\item \textbf{Lato Organizzatore} 
	\begin{enumerate}
		\item Creazione di una nuova caccia al tesoro
			\begin{enumerate}[label=(\alph*)]
				\item Inserimento del nome
				\item Inserimento di data ed ora di inizio
				\item Scelta del luogo di svolgimento
				\item Aggiunta/Rimozione dei punti di interesse 
				\item Aggiunta del relativo quiz (domanda e risposta) ed indizio per raggiungere il punto di interesse in questione
				\item Diffusione di un codice univoco che identifica la caccia al tesoro e permette l'iscrizione agli utenti
			\end{enumerate}
		\item Caricamento di una caccia al tesoro preesistente
		\begin{enumerate}[label=(\alph*)]
			\item Visualizzazione/Gestione dei punti di interesse già presenti con rispettivi indizi e quiz
			\item Visualizzazione del codice univoco della caccia al tesoro
		\end{enumerate}
	\item Gestione di una caccia al tesoro
		\begin{enumerate}[label=(\alph*)]
			\item 
		\end{enumerate}
	\end{enumerate}
	\item \textbf{Lato Giocatore}
		\begin{enumerate}
			\item Creare un account.
			\begin{enumerate}
				\item [a.] Creare il nome del gruppo.
				\item [b.] Creare la password del gruppo.
				\item [c.] Confermare la nuova password del gruppo.
			\end{enumerate}
			\item Accedere tramite login del gruppo.
			\begin{enumerate}
				\item [a.] Visualizzare la lista delle cacce al tesoro con iscrizioni aperte.
				\item [b.] Scelta di una caccia al tesoro.
				\item [c.] Visualizzare la mappa della caccia al tesoro.
				\item [d.] Riceve i quiz.
				\item [e.] Ricevere gli indizi per raggiungere la nuova caccia al tesoro.
			\end{enumerate}
		\end{enumerate} 
\end{itemize}


\subsection{Requisiti non funzionali}
I requisiti non funzionali sono stati identificati come segue:
\begin{itemize}
	\item Sia la parte desktop che l'applicazione mobile devono essere user-friendly
	\item Tutte le informazioni devono essere memorizzate su un apposito database per garantire il salvataggio dei progessi di gioco
	\item Permettere ai giocatori l'indipendenza dal dispositivo fisico usato per giocare. Ciò implica la possibilità di cambiare il dispositivo in maniera trasparente al sistema
	\item Possibilità da parte di un giocatore di recuperare i progressi della propria partita dopo un malfunzionamento/cambio del dispositivo
\end{itemize}

\newpage
\section{Design architetturale}
%Design architetturale (pattern architetturali usati, componenti del sistema distribuito, scelte tecnologiche cruciali ai fini architetturali -- corredato da pochi ma efficaci diagrammi)
Sono stati identificati 3 moduli: Desktop, inteso come software dell'organizzatore di cacce al tesoro; Mobile inteso come applicazione dei utilizzata dai partecipanti; Server, cioè modulo demandato allo scambio dei messaggi e alla persistenza.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/domain_model.png}
	\caption{Domain Model}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[width=0.9\textwidth]{img/messages_model.png}
	\caption{Modello Messaggi}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{img/architetturale01.png}
	\caption{Visione d'insieme del sistema}
\end{figure}

\subsection{Desktop}
Il modulo desktop è stato pensato come software fruibile esclusivamente da computer. Un paradigma ad oggetti/funzionale è stato scelto tenendo conto del tipo di applicativo. Tale modulo  comunica esclusivamente con il modulo Server, principalmente per inviare le nuove entità create, come una nuova caccia al tesoro, un nuovo POI,...
\subsubsection{Model-View-Controller}
L'organizzazione del modulo desktop è model view controller, per consentire leggibilità, manutenibilità del codice, ma soprattutto per consentire ai vari membri del team di lavorare contemporaneamente ad elementi distinti dello stesso software.
Il model si occupa dell'invio dei messaggi al server e della ricezione della risposta.
\subsubsection*{Observer}
E' il pattern scelto per la comunicazione model-view e model-controller.

\subsection{App Mobile}
Per l'applicazione mobile, che non prevede grafica elaborata, ne calcolo oneroso, si è pensato di optare per una app ibrida.
Tale scelta comporta minori tempi di sviluppo, possibilità di eseguire il codice su piattaforme differenti e la possibilità di realizzare una interfaccia grafica piacevole tramite fogli di stile.
I possibili contro di tale scelta sono: l'accesso ai sensori del dispositivo potrebbe risultare difficile o impossibile; Le prestazioni potrebbero risultare basse.
il modulo mobile comunica con il Server principalmente per fornire i propri progressi in fase di gioco e per ricevere le informazioni utili al proseguimento della caccia al tesoro.

\subsection{Server}
Il modulo server si occupa della ricezione di messaggi, degli accessi al database e dell'invio delle risposte ai messaggi ricevuti. Riceve messaggi sia dal Desktop che dal Mobile e risponde ad entrambi.
\subsubsection{Middleware}
Per garantire un corretto funzionamento dello scambio messaggi la scelta più ragionevole sembra quella dell'adozione di un middleware che si occupi di assicurare che ogni messaggio venga recapitato e che ogni device comunichi in modo indipendente dagli altri.
\subsubsection{Data Access Layer}
Il data access layer è inteso come il software che, in esecuzione sul server, si occupa di ricevere i messaggi recapitati dal middleware, effettuare le opportune elaborazioni (principalmente lettura e scrittura dal database) e formulare le risposte.
\subsubsection{Database}
Il database è la parte di persistenza dell'intero sistema e memorizza le entità esistenti e l'andamento delle cacce al tesoro.

Di seguito lo schema ER sulla quale è stato costruito il DB, disegnato per inquadrare tutte le possibili entità del nostro progetto, e le relazioni tra esse, con le opportune cardinalità. 

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{img/ER.png}
	\caption{Schema ER del DB}
\end{figure}

\newpage
\section{Design di dettaglio}
%Design di dettaglio (pattern di progettazione, organizzazione del codice -- corredato da pochi ma efficaci diagrammi)
L'applicazione THO, ha lo scopo di gestire le cacce al tesoro create da un organizzatore che dopo aver scelto una location/città in cui svolgere la gara, aver scelto i punti di interesse, aver inserito i relativi indovinelli nei POI e aver fatto iscrivere i team a una caccia ben specifica potrà far partire la gara.
\\Abbiamo deciso che questa applicazione abbia una visione desktop e una mobile.
L’idea di base prevede due macro-sistemi:
\begin{itemize}
	\item L'organizzatore
	\item I giocatori partecipanti alla caccia al tesoro
\end{itemize}
\subsection{Organizzatore}
L’organizzazione di una caccia al tesoro viene fatta tramite un’applicazione desktop che permette all'organizzatore di scegliere una città/location per il gioco tramite una mappa. Attraverso tale mappa ha la possibilità di impostare i punti di interesse che corrisponderanno alle varie tappe del gioco. Ad ogni punto di interesse è associato un mini gioco/indovinello che sarà creato e poi fornito ad ogni team che durante la caccia raggiungerà tale punto. La corretta risoluzione del quiz consentirà al team di avanzare nel gioco.\\
L'organizzatore, a gioco avviato, ha la possibilità di controllarne l'andamento ed eventualmente di dare indicazioni in tempo reale ai team per aiutarli ad arrivare al successivo punto di interesse oppure di inviare un messaggio di vincita della caccia al tesoro da parte di un team.\\

L’organizzatore di una caccia al tesoro avrà a disposizione una interfaccia grafica che gli consenta di creare, modificare e gestire le varie fasi di gioco.\\
Potrà creare una nuova caccia al tesoro scegliendo un nome che la renda riconoscibile, una data ed un orario di svolgimento.\\
L’organizzatore potrà chiudere l’applicazione desktop senza perdere la caccia al tesoro creata, potendola utilizzare, modificare ed avviare in seguito.\\
A sua disposizione ci sarà l’elenco delle cacce al tesoro precedentemente create e non ancora giocate. Potrà selezionarne una ed aprirla, cioè modificarla.\\
L’organizzatore potrà scegliere una città, impostandola come zona principale di svolgimento dell’evento di gioco.\\
Visualizzerà una mappa all’interno dell’interfaccia dove poter inserire, cliccando, tutti i POI della caccia al tesoro.\\
Potrà, al momento della creazione di un POI, specificare un indizio che il giocatore potrà visualizzare e sfruttare per raggiungere il POI stesso.\\
Potrà anche specificare un quiz, con rispettiva risposta, al quale il giocatore dovrà rispondere per poter visualizzare l’indizio precedentemente inserito.\\
L’organizzatore potrà eliminare i POI precedentemente creati.\\
Potrà richiedere un codice numerico da diffondere ai partecipanti, che lo useranno come chiave di accesso per l’iscrizione alla caccia al tesoro.\\
L’organizzatore avrà la possibilità di decidere il momento in cui aprire le iscrizioni alla caccia al tesoro cliccando su in apposito tasto.\\
Analogamente potrà chiudere le iscrizioni.\\
L’organizzatore non potrà modificare la caccia al tesoro se è già in svolgimento, cioè se ne ha già aperto le iscrizioni.\\


\subsection{Giocatore}
Il sistema lato giocatori consiste nello sviluppo di un'applicazione mobile, che attraverso il GPS li colloca sulla mappa di gioco e permette loro di essere avvisati nel momento in cui raggiungono un determinato punto di interesse. Il raggiungimento di un punto di interesse permetterà loro di ricevere il quiz associato a tale punto e, successivamente alla corretta risoluzione del quiz, anche il nuovo indizio che gli consentirà di procedere nel gioco.
\subsection{Desktop}
L'applicazione desktop può essere utilizzata solo dall'organizzatore, 
\subsection{App Mobile}
L'applicazione mobile può essere utilizzata da tutti i giocatori che si sono loggati in una caccia al tesoro,
\subsubsection{Cordova}
L'applicazione mobile l'abbiamo sviluppata con Apache Cordova, abbiamo deciso questa soluzione perchè ci è sembrata la più funzionale per quello che dovevamo fare noi. Apache Cordova è un framework per lo sviluppo di applicazioni sia web che mobile, .
\subsection{Organizzazione del codice}

\subsection{Server}
\subsubsection{Middleware}
Per far si che i vari moduli comunicassero tra loro, abbiamo scelto di utilizzare un middleware, che si occupasse di gestire gli scambi di messaggi tra giocatori, organizzatore e DB. La nostra scelta è ricaduta su RabbitMQ, vista anche la piena integrazione con AWS, che ha fatto si che la sua installazione fosse molto semplice.
RabbitMQ è il più diffuso Message Broker open source. Leggero e facile da eseguire sul cloud. Supporta diversi protocolli di messaggistica. \\
RabbitMQ gira su diversi ambienti cloud e sistemi operativi, e mette a disposizione una larga scala di strumenti di sviluppo per molti dei più popolari linguaggi.
Questo messagge broker funziona come un ufficio di posta. Ci sono due entità, producer e consumer. La prima manda alla seconda un messaggio e la seconda lo riceve. Il messaggio viene conservato prima di essere spedito in un buffer. Abbiamo scelto RabbitMQ perchè ci garantisce:
\begin{itemize}
	\item che il messaggio sia stato inviato e che sia ricevuto dal consumer.
	\item che i messaggi siano inviati in ordine.
	\item che se un messaggio non è riuscito ad arrivare al consumer torna al producer, affinchè il producer non lo riesce a rinviare ed a essere sicuro che il consumer lo abbia ricevuto.
\end{itemize}
Il producer crea il messaggio e lo invia al Message Broker che lo manda al consumer. Il consumer aspetta che gli arrivi un messaggio per poi elaborarli.

\subsubsection{Database}
Dovendo scegliere un DB che fosse accessibile dal nostro server online, siamo tornati a bussare alle porte di AWS, e abbiamo trovato un servizio fatto ad hoc per la nostra necessità.\\
Amazon Relational Database Service (Amazon RDS) semplifica configurazione, utilizzo e ridimensionamento di database relazionali nel cloud. Questo servizio fornisce una capacità ridimensionabile a un costo conveniente, automatizzando al tempo stesso le attività di amministrazione del database più dispendiose in termini di tempo, quali il provisioning di hardware, l'impostazione di database, gli aggiornamenti e i backup. Consente di concentrarsi sulle proprie applicazioni per fornire le prestazioni ottimali, la disponibilità elevata, la sicurezza e la compatibilità di cui hanno bisogno.

Amazon RDS è disponibile in diversi tipi di istanza database, ottimizzati per la memoria, prestazioni o I/O, e permette di scegliere tra sei motori di database comuni, fra cui Amazon Aurora, PostgreSQL, MySQL, MariaDB, Oracle e Microsoft SQL Server. Si può utilizzare l'AWS Database Migration Service per migrare o replicare facilmente database esistenti verso Amazon RDS.

La nostra scelta, anche per utilizzi pregressi, è stata MySQL. Il Database è usato in modo centralizzato, quindi memorizza solo i dati che devono essere permanenti, ovvero:
\begin{itemize}
	\item Cacce al tesoro inserite, con relativi punti di interesse, quiz con risposta e indizio per raggiungerli.
	\item Squadre, con relative iscrizioni alle cacce al tesoro. 
	\item Organizzatori
	\item Eventi di gioco, che tracciano tutto quello che succede durante lo svolgimento di una caccia al tesoro.
\end{itemize}

Quest'ultima tabella è quella più importante per quanto riguarda il flusso di gioco, poichè memorizza ogni evento relativo al gioco in corso, e garantisce persistenza dei dati. Tramite l'utilizzo di questa tabella di log, è possibile risalire in qualsiasi momento ai progressi fatti da ciascun attore del sistema, rimanendo indipendenti dal dispositivo con la quale l'utente gioca.

\subsubsection{Data Access Layer}
La parte principale del nostro server è il Receiver da noi implementato, che ha il compito di gestire i messaggi in entrata/uscita interfacciandosi con RabbitMQ (che gira sullo stesso server) e occuparsi di fare le operazioni sul DB. La figura 3 illustra quali sono tutte le parti in causa.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{img/rabbit.png}
	\caption{RabbitMQ e Database}
\end{figure}

Il Receiver gestisce sia le comunicazioni da parte dell'organizzatore che da parte del giocatore, e fa si che organizzatore e giocatore non comunichino mai direttamente tra loro. Di seguito alcuni flussi di gioco schematizzati:

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{img/SequenceDiagram/userLogin.png}
	\caption{User Authentication}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{img/SequenceDiagram/userReachAPOI.png}
	\caption{User Reach a POI}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{img/SequenceDiagram/organizerCreateTH.png}
	\caption{Organizer Create a Treasure Hunt}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{img/SequenceDiagram/organizerAddNewPOI.png}
	\caption{Organizer Add a New POI}
\end{figure}

\newpage
\section{Implementazione}
\subsection{Ashley Caselli}
\begin{itemize}
	\item Configurazione di Gradle e Travis CI;
	\item organizer: mvc organization;
	\item organizer modelBroker: message sender/receiver;
	\item organizer javaFX;
	\item organizer grafic interface with Google Maps;
	\item Entità principali comuni a tutti i moduli software in collaborazione con Giacomo Mambelli
	\item Creazione dei messaggi in collaborazione con Giacomo Mambelli
\end{itemize}
\subsection{Carmine Vattimo}
Il mio contributo al progetto THO (Treasure Hunt Organizer) ha riguardato principalmente i seguenti aspetti:
\begin{itemize}
	\item Creazione dell'Istanza del Server Amazon EC2 Micro
	\item Installazione di RabbitMQ: Middleware per scambio di messaggi
	\item Creazione dell'istanza del database MySQL su Amazon RDS
	\item Progettazione e creazione del DB
	\item Data Access Layer: Comunicazione con il DB per tutti i tipi di messaggi e gestione delle operazioni
	\item Mobile App: Cura dello stile e di alcune funzionalità
\end{itemize}
\subsubsection{Istanza del Server Amazon EC2 Micro}
Per la scelta del server da utilizzare, abbiamo preferito appoggiarci su un server online gratuito, messoci a disposizione da Amazon Web Services, piuttosto che utilizzare un server in locale.\\
Amazon Elastic Compute Cloud (Amazon EC2) è un servizio Web che fornisce capacità di elaborazione sicura e scalabile nel cloud. È concepito per rendere più semplice il cloud computing su scala Web per gli sviluppatori (in prova gratuita per un 1 anno, con pacchetto "Micro").\\
Questo server ospita sia il Data Access Layer, che comunica direttamente con il DB, che il middleware da noi scelto, di cui si parla nella prossima sezione.

Io mi sono occupato di avviare la procedura per lanciare un istanza, e della configurazione del server perchè ospitasse il nostro software.

\subsubsection{RabbitMQ: Middleware per scambio di messaggi}
Come indicato nel capitolo precedente, abbiamo scelto come Message Broker RabbitMQ. Anche in questo caso mi sono occupato dell'installazione sul server e della configurazione.
\subsubsection{Istanza del Database MySQL: Amazon RDS}
Mi sono occupato di creare e lanciare l'istanza del database su amason RDS, e della sua configurazione.
\subsubsection{Progettazione e Creazione del DB}
In questa parte mi sono occupato di realizzare lo schema ER, eseguire la progettazione logica e creare le tabelle. Per farlo ho utilizzato strumenti precedentemente utilizzati nel corso di basi di dati, quali DB-Main, per gli schemi, e MySQL Workbench, per la creazione delle tabelle e la gestione del Database remoto durante lo svolgimento del progetto. I dettagli di questa parte di lavoro sono meglio descritti nella sezione del Design.
\subsubsection{Data Access Layer: Comunicazione con il DB}
In questa sezione mi sono occupato dell'implementazione di tutte le operazioni da eseguire sul Database. Il codice citato in questa sezione è contenuto nel package "th-server". 

Ho organizzato il codice suddividendo le operazioni per entità, e creando tanti classi quante erano le entità, ciascuna che implementava le operazioni che riguardavano l'entità stessa. Queste classi sono contenute all'interno del package "dboperation".

Le funzionalità implementate nelle classi di cui sopra vengono utilizzate all'interno della classe "Receiver", in base al tipo di messaggio ricevuto tramite RabbitMQ da parte dei giocatori o degli organizzatori.

\subsubsection{Mobile App: Cura dello stile e di alcune funzionalità}
In questa sezione, mi sono occupato di sistemare lo stile della grafica dell'app, e dell'implementazione di alcune delle funzioni javascript relative al flusso di gioco e allo scambio di messaggi, nei casi in cui fosse necessario comunicare con il database.

\subsection{Francesca Tassinari}
Il mio contributo è legato pricipalmente al design della:
\begin{itemize}
	\item applicazione mobile;
	\item applicazione desktop;
\end{itemize}
\subsubsection{Applicazione mobile}
L'applicazione mobile è stata implementata nel package th-player. Abbiamo deciso di svilupparla come applicazione ibrida, basata sul framework Apache Cordova, la motivazione di questa decisione è stata presa perchè abbiamo pensato fosse la soluzione migliore per comprendere tutte le piattaforme mobile. Ho sviluppato l'applicazione mobile tramite cordova implementando in index.html, lo scheletro della pagina aggiungendo i vari bottoni e le caselle di testo per, effettuare il login oppure per il caricamento di una caccia al tesoro. Per lo stile della pagina ho pensato fosse meglio svilupparlo tramite Sass che introduce una nuova sintassi nota come SCSS che è pienamente compatibile con la sintassi dei CSS. Poiché SCSS è un'estensione CSS, tutto ciò che funziona in CSS funziona in SCSS. In Sass a differenza del CSS si possono utilizzare variabili e fare mixing di diverse pagine SCSS. Per elaborare i dati oppure fare calcoli della pagina html ho sviluppato index.js, una pagina Javascript dove riusciamo, tramite localstrorage, a salvarci i dati che abbiamo aggiunto nel momento del login oppure quando stiamo per caricare una nuova caccia al tesoro. Abbiamo aggiunto la mappa nella applicazione mobile dove io ho creato i vari bottoni per es:visualizzare l'ultimo indizio ecc.
\subsubsection {Applicazione desktop}
Nell'applicazione desktop, che utilizzerà l'organizzatore della caccia al tesoro per creare una nuova caccia oppure per iniziare una già ideata, ho creato il bottone per l'avvio della caccia al tesoro comunicando al broker tramite un invio di un messaggio che la caccia è partita. La stessa cosa è stata fatta per il bottone di stop di una caccia al tesoro, ovvero tramite uno scambio di messaggi viene comunicato lo stop della caccia, essa poi viene stoppata proprio quando l'organizzatore decide che quella caccia al tesoro è conclusa.
\subsubsection{Creazionione nuovi Poi}
Abbiamo deciso di far visualizzare una mappa del luogo della caccia al tesoro, appena viene creata una nuova caccia oppure quando verrà caricata. La mappa del luogo visualizzerà dove si svolgerà la caccia al tesoro. Ho implementato la funzionalità di aggiunta di un marker cliccando direttamente sulla mappa e in di inserire i rispettivi quiz del poi in cui ci si trova, e dell'indizio per trovare il punto di interesse successivo.
\subsection{Giacomo Mambelli}
Nel progetto Treasure Hunt Organizer, Giacomo Mambelli si è occupato principalmente delle fasi di design e implementazione di:
\begin{itemize}
	\item Entità principali comuni a tutti i moduli software in collaborazione con Ashley Caselli
	\item Creazione dei messaggi in collaborazione con Ashley Caselli
	\item Applicazione mobile
	\item Data access layer - Receiver
	\item Organizer model
\end{itemize}
\subsubsection{Applicazione mobile}
Il codice citato in questa sezione è contenuto nel package th-player.
L'applicazione è stata sviluppata come app ibrida, il framework utilizzato è Apache Cordova.
Tale software è attualmente fruibile tramite browser e android apk.
Le schermate principali, presentate nell'immagine seguente, sono: Scelta login/registrazione, Login, Registrazione, Scelta caccia al tesoro, Inserimento codice di accesso, Gioco, Pausa.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{img/flusso01.png}
	\caption{Schermate app Android}
\end{figure}

\subsubsection*{Login}
Alla prima apertura dell'applicazione l'utente viene guidato dall'interfaccia grafica nella creazione di un nuovo account il quale si concretizza in nome e password. Eseguita la registrazione, il login è automatico.
E' possibile effettuare il login, partendo dalla schermata principale della app, in un account precedentemente creato.
L'utente loggato può fare logout cliccando sul nome utente che viene visualizzato nella bottom-bar della applicazione.
Per mantenere le informazioni sull'ultimo utente che ha effettuato l'accesso sono state utilizzate le local storage di HTML, che garantiscono la persistenza di piccole quantità di informazione sul device. Il logout comporta l'abbandono automatico della caccia al tesoro a cui l'utente sta partecipando (se esiste) con la relativa cancellazione dei dati persistenti e la rimozione di tutti i dati relativi all'utente salvati in fase di login.
Il controllo sulla validità dei dati inseriti nella form di login, così come il controllo sull'esistenza di un account con lo stesso username in fase di registrazione è stato implementato come scambio di messaggi con il server.
Viene inviato un LoginMsg (o RegistrationMsg) in formato testuale Json contenente i username e password alla coda opportuna di RabbitMQ; l'applicazione server legge il messaggio dalla coda di RabbitMQ e chiama l'esecuzione delle verifiche sul database. La risposta, affermativa o negativa, compie il percorso inverso.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{img/diagram03.png}
	\caption{Login, visione del sistema}
\end{figure}

\subsubsection*{Mappa}
Per fornire precise informazioni al giocatore rispetto alla sua posizione si è deciso di incorporare una mappa all'interno della schermata di gioco.
La mappa scelta è quella di Google. Google Maps fornisce infatti API utilizzabili dalla maggior parte di sistemi software. In particolare è possibile richiamare le API Google tramite codice JavaScript importando uno script.
L'applicazione richiede pertanto le autorizzazioni necessarie per acquisire la posizione GPS del device. E stato necessario specificare nel file Manifest di Android l'utilizzo di tali dati da parte della app. L'utente dovrà accettare (in modo differente a seconda della piattaforma che utilizza) di fornire i dati relativi alla posizione per poter giocare correttamente.

\subsubsection*{Scambio Messaggi}
Lo scambio di messaggi con il server è stato realizzato sfruttando il middleware RabbitMQ.
Lato device è stato utilizzato il protocollo STOMP tramite WebSocket.
Il device apre una connessione al server al momento dell'avvio e ripristina la connessione ogni volta che essa viene persa.
Per evitare problemi di compatibilità con i vari browser si è deciso di aggiungere un ulteriore strato di WebSocket emulate con il plugin SockJ che è in grado di funzionare anche su browser che non supportano nativamente le WebSocket.
La connessione viene aperta dalla funzione connect() che imposta l'heartbeat a zero poiché non supportato dal plugin SockJS e successivamente contatta il server all'url specificato fornendo credenziali e callback.
I messaggi vengono inviati tramite una funzione denominata send() che comunica al server la queue alla quale è indirizzato il messaggio; una queue temporanea che viene creata al momento dell'invio tramite la quale ricevere la risposta ed il messaggio in formato testuale (Json) ricevuto in ingresso.
La funzione onReceive() è delegata alla ricezione dei messaggi sulla queue temporanea creata in fase di invio. Al suo interno il riconoscimento del tipo di messaggio basata sul campo messageType e la chiamata alla funzione corretta per la gestione dei vai tipi.
Tutti i messaggi sono in formato Json e devono pertanto essere deserializzati per poter essere sfruttati.

\subsubsection{Data access layer - Receiver}
Il data access layer necessita di un modulo per la ricezione dei messaggi recapitati da RabbitMQ. Tale modulo si concretizza in una classe denominata Receiver il cui compito è ricevere i messaggi, interpretarli e chiamare le corrette operazioni sul database attraverso le altre classi del data access layer.

\subsubsection*{Connection and queue declare}
La classe Receiver, alla chiamata del metodo startRecv(), apre una connessione con RabbitMQ e crea 3 code:
la prima sulla quale il receiver ascolta i messaggi in arrivo dall'organizzatore e sul quale inoltra le risposte;
la seconda sulla quale ascolta i messaggi in arrivo dai giocatori (la risposta viene inviata su un canale temporaneo creato dal mittente);
la terza è una coda dedicata al messaggio di fine caccia al tesoro sulla quale tutti i giocatori ascoltano (e nessuno rimuove il messaggio).

\subsubsection*{Message recognition and Deserialization}
Ogni canale sul quale il receiver deve ricevere messaggi gestisce le stringhe in ingresso trasformandole in un istanza di Message con una chiamata al metodo .as[Message] della libreria Json Play che è in grado di deserializzare il messaggio utilizzando la variabile implicita reads definita all'interno dell'oggetto Message tramite la chiamata a defaultRepresentation. Ogni istanza di Message contiene un campo messageType che viene utilizzato per deserializzare il contenuto del messaggio portandolo al tipo originale chiamando ancora .as[messageType].
Per ogni tipo di messaggio ricevuto vengono chiamate le opportune funzione di lettura/aggiornamento/cancellazione del database.
La risposta viene inviata con una chiamata basicPublish() sull'opportuna coda.

\subsubsection{Organizer model}
La classe THModel del modulo desktop rappresenta la logica dell'applicazione organizzatore.
Le funzioni implementate al suo interno hanno nella quasi totalità dei casi una triplice funzione:
\begin{itemize}
	\item Comunicare al server la creazione/eliminazione di una entità
	\item Mantenere e aggiornare strutture dati locali che modellino lo stato corrente della caccia al tesoro aperta
	\item Notificare gli observer
\end{itemize}
\subsubsection*{Comunicazione col server}
Lo scambio di messaggi viene gestito tramite chiamate al broker al quale viene passato un messaggio già serializzato. La risposta viene deserializzata e opportunamente gestita.
\subsubsection*{Dati in locale}
Il model salva all'interno delle opportune strutture dati la lista delle cacce al tesoro disponibili ricevuta dal server, la caccia al tesoro corrente e una lista dei POI della caccia corrente (ognuno dei quali contiene clue, quiz, position,...)
\subsubsection*{Notifica agli observer}
La notifica di un avvenuto cambiamento ai dati agli observer viene effettuata con la chiamata a notifyObservers() che riceve in ingresso dati sottoforma di messaggio serializzato.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{img/code01.png}
	\caption{Esempio funzione scala}
\end{figure}

\subsection{Parti in comune}

\subsubsection{Entità principali ( Caselli - Mambelli )}
Questa sezione illustra quali elementi di una caccia al tesoro si è deciso di modellare.
Le varie classi rappresentanti entità del dominio applicativo sono state collocate nel package core.domanin, importato sia dal modulo server che da quello desktop.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{img/diagram01.png}
	\caption{Trait a classi principali}
\end{figure}

\subsubsection*{Trait Serializable e Positionable}
Serializable e Positionable sono i due trai fondamentali del package.
Le classi che estendono da Serializable implementano il metodo defaultRepresentation: String che restituisce la rappresentazione testuale, in formato Json, delle istanze della classe stessa.\\
Positionable modella il concetto di entità con posizione, cioè che contiene al suo interno una Position. PositionImpl implementa il trait Position e di conseguenza contiene latitude e longitude. Il trait Position è Serializable.

\subsubsection*{Point Of Interest}
L'elemento principale del dominio applicativo è il punto di interesse (POI), inteso come "tappa" della caccia al tesoro.
Il trait POI prevede getter/setter per: ID identificativo numerico del punto, name Nome del punto, treasureHuntID identificativo numerico della caccia al tesoro di appartenenza, clue l'indizio utile per il raggiungimento del POI, e quiz il Quiz che deve essere risolto per avere accesso all'indizio.
La nostra implementazione del trait (POIImpl), essendo il trait POI estensione di Serializable, prevede una implementazione attraverso una implicit val del metodo defaultRepresentation. La deserializzazione è affidata all'object POI.
POI è, ovviamente, anche Positionable.\\
Esiste poi un trait ListPOIs, anch'esso serializzabile, con relativa implementazione che modella un elenco di POI inteso come tutti i punti di una caccia al tesoro.\\
In modo analogo sono modellate tutte le entità. Ad esempio: Quiz serializable e contenente 2 stringhe che rappresentano domanda e risposta corretta; Clue serializable e contenente una stringha che rappresenta l'indizio; Login e Registration che contengono i dati dell'utente, State che modella uno stato di una specifica caccia al tesoro,...

\subsubsection{Creazione dei messaggi ( Caselli - Mambelli )}
Esiste una corrispondenza quasi 1-1 tra i trait presentati nel paragrafo precedente ed i messaggi contenuti nel package core.domain.messages.\\
E' infatti possibile inviare, appoggiandosi a RabbitMQ, la quasi totalità degli elementi del domain inserendo la defaultRepresentation di ognuno di essi nel rispettivo messaggio, a sua volta serializzato e spedito.
L'invio di messaggi è possibile sia tra desktop e server che tra mobile e server, ma non direttamente tra desktop e mobile.
Tutti i messaggi sono serializzabili, contengono un campo sender che rappresenta il mittente e un campo payload:String che rappresenta la defaultRepresentation dell'oggetto che è stato inviato.
Un terzo campo messageType rappresenta il tipo di messaggio cioè quale classe è contenuta nel suo payload.
I tipi di messaggio sono elencati nella Enumeration msgType, nello stesso file di Message.\\
La serializzazione e deserializzazione dei messaggi avviene analogamente a quella delle classi citate nel paragrafo precedente.
L'eccezione NoMsgDefinedException viene lanciata nel caso il msgType sia sconosciuto e, pertanto, la deserializzazione impossibile.

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{img/diagram02.png}
	\caption{Trait e classi Message}
\end{figure}

\newpage
\section{Retrospettiva}
%Restrospettiva (descrizione finale dettagliata dell'andamento dello sviluppo, del backlog, delle iterazioni; commenti finali)
Abbiamo pianificato su Trello i 5 sprint da 20 ore, in cui a fine di ognuno di essi, abbiamo fatto una sprint review.\\Dopo aver svolto l'analisi del problema abbiamo creato il Product Backlog composto da varie user story, suddivise nei 5 sprint in ordine di priorità. \\
Le user story sono poi state ampliate in vari task, che durante le sprint review ogni membro del team doveva assegnarsi per poi portare a termine. \\Una sprint review iniziava raccontandoci e spiegandoci cosa, uno o più membri del gruppo, avevano fatto durante i giorni trascorsi. A fine di ogni sprint review si valutava il lavoro compiuto, si creava nuovi task, ci si divideva i nuovi compiti e si stabiliva, approssimativamente, il tempo pensato per lo svolgimento dei nuovi task assegnati. Durante queste sprint review è stato possibile monitorare l'avanzamento del progetto. Inizialmente abbiamo avuto qualche difficoltà a utilizzare la modalità di sviluppo Scrum, perchè non avevamo chiaro come si costruiva e come funzionava un Product Backlog. Qualche difficoltà durante l'avvio del progetto l'abbiamo riscontrata anche nello stimare i tempi per lo svolgimento di ogni singolo task, non sapevamo come calcolare le ore e come metterle nel Product Backlog. Sfortunatamente non siamo neanche riusciti a suddividerci il lavoro in modo equo. E' stato veramente un lavoro di squadra dove ognuno metteva in campo il proprio sapere. A volte alcuni task venivano anche svolti insieme fra alcuni membri del progetto affinchè il know-how di ogni componente potesse aumentare grazie all'altra persona.

\begin{itemize}
	\item creare per i giocatori che parteciperanno a team un metodo per gestire loro più device che però si riferiscano al loro team;
	\item creare un messaggio che dopo un timer definito dall'organizzatore, che mandi dal device del team la sua posizione alla applicazione desktop per mostrare dove si trovano e l'organizzarore possa mandare un messaggio per aiutarli a trovare il prossimo punto di interesse;
	\item 
\end{itemize}
\vspace{-30pt}
\end{document}